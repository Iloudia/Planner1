import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/highcharts/modules/exporting.js
var require_exporting = __commonJS({
  "node_modules/highcharts/modules/exporting.js"(exports, module) {
    !/**
    * Highcharts JS v12.4.0 (2025-09-04)
    * @module highcharts/modules/exporting
    * @requires highcharts
    *
    * Exporting module
    *
    * (c) 2010-2025 Torstein Honsi
    *
    * License: www.highcharts.com/license
    */
    function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t(e._Highcharts, e._Highcharts.AST, e._Highcharts.Chart) : "function" == typeof define && define.amd ? define("highcharts/modules/exporting", ["highcharts/highcharts"], function(e2) {
        return t(e2, e2.AST, e2.Chart);
      }) : "object" == typeof exports ? exports["highcharts/modules/exporting"] = t(e._Highcharts, e._Highcharts.AST, e._Highcharts.Chart) : e.Highcharts = t(e.Highcharts, e.Highcharts.AST, e.Highcharts.Chart);
    }("undefined" == typeof window ? exports : window, (e, t, n) => (() => {
      "use strict";
      var i, o, r = { 660: (e2) => {
        e2.exports = t;
      }, 944: (t2) => {
        t2.exports = e;
      }, 960: (e2) => {
        e2.exports = n;
      } }, a = {};
      function s(e2) {
        var t2 = a[e2];
        if (void 0 !== t2) return t2.exports;
        var n2 = a[e2] = { exports: {} };
        return r[e2](n2, n2.exports, s), n2.exports;
      }
      s.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return s.d(t2, { a: t2 }), t2;
      }, s.d = (e2, t2) => {
        for (var n2 in t2) s.o(t2, n2) && !s.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
      }, s.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
      var l = {};
      s.d(l, { default: () => eu });
      var c = s(944), h = s.n(c), p = s(660), d = s.n(p), u = s(960), g = s.n(u);
      !function(e2) {
        e2.compose = function(e3) {
          return e3.navigation || (e3.navigation = new t2(e3)), e3;
        };
        class t2 {
          constructor(e3) {
            this.updates = [], this.chart = e3;
          }
          addUpdate(e3) {
            this.chart.navigation.updates.push(e3);
          }
          update(e3, t3) {
            this.updates.forEach((n2) => {
              n2.call(this.chart, e3, t3);
            });
          }
        }
        e2.Additions = t2;
      }(i || (i = {}));
      let f = i, { isSafari: m, win: y, win: { document: x } } = h(), { error: w } = h(), b = y.URL || y.webkitURL || y;
      function v(e2) {
        let t2 = e2.replace(/filename=.*;/, "").match(/data:([^;]*)(;base64)?,([A-Z+\d\/]+)/i);
        if (t2 && t2.length > 3 && y.atob && y.ArrayBuffer && y.Uint8Array && y.Blob && b.createObjectURL) {
          let e3 = y.atob(t2[3]), n2 = new y.ArrayBuffer(e3.length), i2 = new y.Uint8Array(n2);
          for (let t3 = 0; t3 < i2.length; ++t3) i2[t3] = e3.charCodeAt(t3);
          return b.createObjectURL(new y.Blob([i2], { type: t2[1] }));
        }
      }
      let { isTouchDevice: S } = h(), C = { exporting: { allowTableSorting: true, libURL: "https://code.highcharts.com/12.4.0/lib/", local: true, type: "image/png", url: `https://export-svg.highcharts.com?v=${h().version}`, pdfFont: { normal: void 0, bold: void 0, bolditalic: void 0, italic: void 0 }, printMaxWidth: 780, scale: 2, buttons: { contextButton: { className: "highcharts-contextbutton", menuClassName: "highcharts-contextmenu", symbol: "menu", titleKey: "contextButtonTitle", menuItems: ["viewFullscreen", "printChart", "separator", "downloadPNG", "downloadJPEG", "downloadSVG"] } }, menuItemDefinitions: { viewFullscreen: { textKey: "viewFullscreen", onclick: function() {
        var _a;
        (_a = this.fullscreen) == null ? void 0 : _a.toggle();
      } }, printChart: { textKey: "printChart", onclick: function() {
        var _a;
        (_a = this.exporting) == null ? void 0 : _a.print();
      } }, separator: { separator: true }, downloadPNG: { textKey: "downloadPNG", onclick: async function() {
        var _a;
        await ((_a = this.exporting) == null ? void 0 : _a.exportChart());
      } }, downloadJPEG: { textKey: "downloadJPEG", onclick: async function() {
        var _a;
        await ((_a = this.exporting) == null ? void 0 : _a.exportChart({ type: "image/jpeg" }));
      } }, downloadPDF: { textKey: "downloadPDF", onclick: async function() {
        var _a;
        await ((_a = this.exporting) == null ? void 0 : _a.exportChart({ type: "application/pdf" }));
      } }, downloadSVG: { textKey: "downloadSVG", onclick: async function() {
        var _a;
        await ((_a = this.exporting) == null ? void 0 : _a.exportChart({ type: "image/svg+xml" }));
      } } } }, lang: { viewFullscreen: "View in full screen", exitFullscreen: "Exit from full screen", printChart: "Print chart", downloadPNG: "Download PNG image", downloadJPEG: "Download JPEG image", downloadPDF: "Download PDF document", downloadSVG: "Download SVG vector image", contextButtonTitle: "Chart context menu" }, navigation: { buttonOptions: { symbolSize: 14, symbolX: 14.5, symbolY: 13.5, align: "right", buttonSpacing: 5, height: 28, y: -5, verticalAlign: "top", width: 28, symbolFill: "#666666", symbolStroke: "#666666", symbolStrokeWidth: 3, theme: { fill: "#ffffff", padding: 5, stroke: "none", "stroke-linecap": "round" } }, menuStyle: { border: "none", borderRadius: "3px", background: "#ffffff", padding: "0.5em" }, menuItemStyle: { background: "none", borderRadius: "3px", color: "#333333", padding: "0.5em", fontSize: S ? "0.9em" : "0.8em", transition: "background 250ms, color 250ms" }, menuItemHoverStyle: { background: "#f2f2f2" } } };
      !function(e2) {
        let t2 = [];
        function n2(e3, t3, n3, i3) {
          return [["M", e3, t3 + 2.5], ["L", e3 + n3, t3 + 2.5], ["M", e3, t3 + i3 / 2 + 0.5], ["L", e3 + n3, t3 + i3 / 2 + 0.5], ["M", e3, t3 + i3 - 1.5], ["L", e3 + n3, t3 + i3 - 1.5]];
        }
        function i2(e3, t3, n3, i3) {
          let o2 = i3 / 3 - 2, r2 = [];
          return r2.concat(this.circle(n3 - o2, t3, o2, o2), this.circle(n3 - o2, t3 + o2 + 4, o2, o2), this.circle(n3 - o2, t3 + 2 * (o2 + 4), o2, o2));
        }
        e2.compose = function(e3) {
          if (-1 === t2.indexOf(e3)) {
            t2.push(e3);
            let o2 = e3.prototype.symbols;
            o2.menu = n2, o2.menuball = i2.bind(o2);
          }
        };
      }(o || (o = {}));
      let E = o, { composed: O } = h(), { addEvent: T, fireEvent: k, pushUnique: F } = h();
      function R() {
        this.fullscreen = new N(this);
      }
      class N {
        static compose(e2) {
          F(O, "Fullscreen") && T(e2, "beforeRender", R);
        }
        constructor(e2) {
          this.chart = e2, this.isOpen = false;
          let t2 = e2.renderTo;
          !this.browserProps && ("function" == typeof t2.requestFullscreen ? this.browserProps = { fullscreenChange: "fullscreenchange", requestFullscreen: "requestFullscreen", exitFullscreen: "exitFullscreen" } : t2.mozRequestFullScreen ? this.browserProps = { fullscreenChange: "mozfullscreenchange", requestFullscreen: "mozRequestFullScreen", exitFullscreen: "mozCancelFullScreen" } : t2.webkitRequestFullScreen ? this.browserProps = { fullscreenChange: "webkitfullscreenchange", requestFullscreen: "webkitRequestFullScreen", exitFullscreen: "webkitExitFullscreen" } : t2.msRequestFullscreen && (this.browserProps = { fullscreenChange: "MSFullscreenChange", requestFullscreen: "msRequestFullscreen", exitFullscreen: "msExitFullscreen" }));
        }
        close() {
          let e2 = this, t2 = e2.chart, n2 = t2.options.chart;
          k(t2, "fullscreenClose", null, function() {
            e2.isOpen && e2.browserProps && t2.container.ownerDocument instanceof Document && t2.container.ownerDocument[e2.browserProps.exitFullscreen](), e2.unbindFullscreenEvent && (e2.unbindFullscreenEvent = e2.unbindFullscreenEvent()), t2.setSize(e2.origWidth, e2.origHeight, false), e2.origWidth = void 0, e2.origHeight = void 0, n2.width = e2.origWidthOption, n2.height = e2.origHeightOption, e2.origWidthOption = void 0, e2.origHeightOption = void 0, e2.isOpen = false, e2.setButtonText();
          });
        }
        open() {
          let e2 = this, t2 = e2.chart, n2 = t2.options.chart;
          k(t2, "fullscreenOpen", null, function() {
            if (n2 && (e2.origWidthOption = n2.width, e2.origHeightOption = n2.height), e2.origWidth = t2.chartWidth, e2.origHeight = t2.chartHeight, e2.browserProps) {
              let n3 = T(t2.container.ownerDocument, e2.browserProps.fullscreenChange, function() {
                e2.isOpen ? (e2.isOpen = false, e2.close()) : (t2.setSize(null, null, false), e2.isOpen = true, e2.setButtonText());
              }), i2 = T(t2, "destroy", n3);
              e2.unbindFullscreenEvent = () => {
                n3(), i2();
              };
              let o2 = t2.renderTo[e2.browserProps.requestFullscreen]();
              o2 && o2.catch(function() {
                alert("Full screen is not supported inside a frame.");
              });
            }
          });
        }
        setButtonText() {
          var _a;
          let e2 = this.chart, t2 = (_a = e2.exporting) == null ? void 0 : _a.divElements, n2 = e2.options.exporting, i2 = n2 && n2.buttons && n2.buttons.contextButton.menuItems, o2 = e2.options.lang;
          if (n2 && n2.menuItemDefinitions && o2 && o2.exitFullscreen && o2.viewFullscreen && i2 && t2) {
            let e3 = t2[i2.indexOf("viewFullscreen")];
            e3 && d().setElementHTML(e3, this.isOpen ? o2.exitFullscreen : n2.menuItemDefinitions.viewFullscreen.text || o2.viewFullscreen);
          }
        }
        toggle() {
          this.isOpen ? this.close() : this.open();
        }
      }
      let { win: P } = h(), { discardElement: H, objectEach: L } = h(), M = { ajax: function(e2) {
        var _a;
        let t2 = { json: "application/json", xml: "application/xml", text: "text/plain", octet: "application/octet-stream" }, n2 = new XMLHttpRequest();
        function i2(t3, n3) {
          e2.error && e2.error(t3, n3);
        }
        if (!e2.url) return false;
        n2.open((e2.type || "get").toUpperCase(), e2.url, true), ((_a = e2.headers) == null ? void 0 : _a["Content-Type"]) || n2.setRequestHeader("Content-Type", t2[e2.dataType || "json"] || t2.text), L(e2.headers, function(e3, t3) {
          n2.setRequestHeader(t3, e3);
        }), e2.responseType && (n2.responseType = e2.responseType), n2.onreadystatechange = function() {
          var _a2;
          let t3;
          if (4 === n2.readyState) {
            if (200 === n2.status) {
              if ("blob" !== e2.responseType && (t3 = n2.responseText, "json" === e2.dataType)) try {
                t3 = JSON.parse(t3);
              } catch (e3) {
                if (e3 instanceof Error) return i2(n2, e3);
              }
              return (_a2 = e2.success) == null ? void 0 : _a2.call(e2, t3, n2);
            }
            i2(n2, n2.responseText);
          }
        }, e2.data && "string" != typeof e2.data && (e2.data = JSON.stringify(e2.data)), n2.send(e2.data);
      }, getJSON: function(e2, t2) {
        M.ajax({ url: e2, success: t2, dataType: "json", headers: { "Content-Type": "text/plain" } });
      }, post: async function(e2, t2, n2) {
        let i2 = new P.FormData();
        L(t2, function(e3, t3) {
          i2.append(t3, e3);
        }), i2.append("b64", "true");
        let o2 = await P.fetch(e2, { method: "POST", body: i2, ...n2 });
        if (o2.ok) {
          let e3 = await o2.text(), n3 = document.createElement("a");
          n3.href = `data:${t2.type};base64,${e3}`, n3.download = t2.filename, n3.click(), H(n3);
        }
      } }, { defaultOptions: A, setOptions: D } = h(), { downloadURL: U, getScript: I } = { dataURLtoBlob: v, downloadURL: function(e2, t2) {
        let n2 = y.navigator, i2 = x.createElement("a");
        if ("string" != typeof e2 && !(e2 instanceof String) && n2.msSaveOrOpenBlob) return void n2.msSaveOrOpenBlob(e2, t2);
        if (e2 = "" + e2, n2.userAgent.length > 1e3) throw Error("Input too long");
        let o2 = /Edge\/\d+/.test(n2.userAgent);
        if ((m && "string" == typeof e2 && 0 === e2.indexOf("data:application/pdf") || o2 || e2.length > 2e6) && !(e2 = v(e2) || "")) throw Error("Failed to convert to blob");
        if (void 0 !== i2.download) i2.href = e2, i2.download = t2, x.body.appendChild(i2), i2.click(), x.body.removeChild(i2);
        else try {
          if (!y.open(e2, "chart")) throw Error("Failed to open window");
        } catch {
          y.location.href = e2;
        }
      }, getScript: function(e2) {
        return new Promise((t2, n2) => {
          let i2 = x.getElementsByTagName("head")[0], o2 = x.createElement("script");
          o2.type = "text/javascript", o2.src = e2, o2.onload = () => {
            t2();
          }, o2.onerror = () => {
            let t3 = `Error loading script ${e2}`;
            w(t3), n2(Error(t3));
          }, i2.appendChild(o2);
        });
      } }, { composed: j, doc: B, isFirefox: G, isMS: $, isSafari: V, SVG_NS: W, win: q } = h(), { addEvent: z, clearTimeout: K, createElement: J, css: _, discardElement: X, error: Y, extend: Z, find: Q, fireEvent: ee, isObject: et, merge: en, objectEach: ei, pick: eo, pushUnique: er, removeEvent: ea, splat: es, uniqueKey: el } = h();
      d().allowedAttributes.push("data-z-index", "fill-opacity", "filter", "preserveAspectRatio", "rx", "ry", "stroke-dasharray", "stroke-linejoin", "stroke-opacity", "text-anchor", "transform", "transform-origin", "version", "viewBox", "visibility", "xmlns", "xmlns:xlink"), d().allowedTags.push("desc", "clippath", "fedropshadow", "femorphology", "g", "image");
      let ec = q.URL || q.webkitURL || q;
      class eh {
        constructor(e2, t2) {
          this.options = {}, this.chart = e2, this.options = t2, this.btnCount = 0, this.buttonOffset = 0, this.divElements = [], this.svgElements = [];
        }
        static hyphenate(e2) {
          return e2.replace(/[A-Z]/g, function(e3) {
            return "-" + e3.toLowerCase();
          });
        }
        static async imageToDataURL(e2, t2, n2) {
          let i2 = await eh.loadImage(e2), o2 = B.createElement("canvas"), r2 = o2 == null ? void 0 : o2.getContext("2d");
          if (r2) return o2.height = i2.height * t2, o2.width = i2.width * t2, r2.drawImage(i2, 0, 0, o2.width, o2.height), o2.toDataURL(n2);
          throw Error("No canvas found!");
        }
        static async fetchCSS(e2) {
          let t2 = await fetch(e2).then((e3) => e3.text()), n2 = new CSSStyleSheet();
          return n2.replaceSync(t2), n2;
        }
        static async handleStyleSheet(e2, t2) {
          try {
            for (let n2 of Array.from(e2.cssRules)) {
              if (n2 instanceof CSSImportRule) {
                let e3 = await eh.fetchCSS(n2.href);
                await eh.handleStyleSheet(e3, t2);
              }
              if (n2 instanceof CSSFontFaceRule) {
                let i2 = n2.cssText;
                if (e2.href) {
                  let t3 = e2.href, n3 = /url\(\s*(['"]?)(?![a-z]+:|\/\/)([^'")]+?)\1\s*\)/gi;
                  i2 = i2.replace(n3, (e3, n4, i3) => {
                    let o2 = new URL(i3, t3).href;
                    return `url(${n4}${o2}${n4})`;
                  });
                }
                t2.push(i2);
              }
            }
          } catch {
            if (e2.href) {
              let n2 = await eh.fetchCSS(e2.href);
              await eh.handleStyleSheet(n2, t2);
            }
          }
        }
        static async fetchStyleSheets() {
          let e2 = [];
          for (let t2 of Array.from(B.styleSheets)) await eh.handleStyleSheet(t2, e2);
          return e2;
        }
        static async inlineFonts(e2) {
          let t2 = await eh.fetchStyleSheets(), n2 = /url\(([^)]+)\)/g, i2 = [], o2 = t2.join("\n"), r2;
          for (; r2 = n2.exec(o2); ) {
            let e3 = r2[1].replace(/['"]/g, "");
            i2.includes(e3) || i2.push(e3);
          }
          let a2 = (e3) => {
            let t3 = "", n3 = new Uint8Array(e3);
            for (let e4 = 0; e4 < n3.byteLength; e4++) t3 += String.fromCharCode(n3[e4]);
            return btoa(t3);
          }, s2 = {};
          for (let e3 of i2) try {
            let t3 = await fetch(e3), n3 = t3.headers.get("Content-Type") || "", i3 = a2(await t3.arrayBuffer());
            s2[e3] = `data:${n3};base64,${i3}`;
          } catch {
          }
          o2 = o2.replace(n2, (e3, t3) => {
            let n3 = t3.replace(/['"]/g, "");
            return `url(${s2[n3] || n3})`;
          });
          let l2 = document.createElementNS("http://www.w3.org/2000/svg", "style");
          return l2.textContent = o2, e2.append(l2), e2;
        }
        static loadImage(e2) {
          return new Promise((t2, n2) => {
            let i2 = new q.Image();
            i2.crossOrigin = "Anonymous", i2.onload = () => {
              setTimeout(() => {
                t2(i2);
              }, eh.loadEventDeferDelay);
            }, i2.onerror = (e3) => {
              n2(e3);
            }, i2.src = e2;
          });
        }
        static prepareImageOptions(e2) {
          var _a;
          let t2 = (e2 == null ? void 0 : e2.type) || "image/png", n2 = (e2 == null ? void 0 : e2.libURL) || ((_a = A.exporting) == null ? void 0 : _a.libURL);
          return { type: t2, filename: ((e2 == null ? void 0 : e2.filename) || "chart") + "." + ("image/svg+xml" === t2 ? "svg" : t2.split("/")[1]), scale: (e2 == null ? void 0 : e2.scale) || 1, libURL: (n2 == null ? void 0 : n2.slice(-1)) !== "/" ? n2 + "/" : n2 };
        }
        static sanitizeSVG(e2, t2) {
          var _a;
          let n2 = e2.indexOf("</svg>") + 6, i2 = e2.indexOf("<foreignObject") > -1, o2 = e2.substr(n2);
          return e2 = e2.substr(0, n2), i2 ? e2 = e2.replace(/(<(?:img|br).*?(?=\>))>/g, "$1 />") : o2 && ((_a = t2 == null ? void 0 : t2.exporting) == null ? void 0 : _a.allowHTML) && (o2 = '<foreignObject x="0" y="0" width="' + t2.chart.width + '" height="' + t2.chart.height + '"><body xmlns="http://www.w3.org/1999/xhtml">' + o2.replace(/(<(?:img|br).*?(?=\>))>/g, "$1 />") + "</body></foreignObject>", e2 = e2.replace("</svg>", o2 + "</svg>")), e2 = e2.replace(/zIndex="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery\d+="[^"]+"/g, "").replace(/url\(("|&quot;)(.*?)("|&quot;)\;?\)/g, "url($2)").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ (NS\d+\:)?href=/g, " xlink:href=").replace(/\n+/g, " ").replace(/&nbsp;/g, " ").replace(/&shy;/g, "­");
        }
        static svgToDataURL(e2) {
          let t2 = q.navigator.userAgent, n2 = t2.indexOf("WebKit") > -1 && 0 > t2.indexOf("Chrome");
          try {
            if (!n2 && -1 === e2.indexOf("<foreignObject")) return ec.createObjectURL(new q.Blob([e2], { type: "image/svg+xml;charset-utf-16" }));
          } catch {
          }
          return "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(e2);
        }
        addButton(e2) {
          var _a;
          let t2, n2 = this, i2 = n2.chart, o2 = i2.renderer, r2 = en((_a = i2.options.navigation) == null ? void 0 : _a.buttonOptions, e2), a2 = r2.onclick, s2 = r2.menuItems, l2 = r2.symbolSize || 12;
          if (false === r2.enabled || !r2.theme) return;
          let c2 = i2.styledMode ? {} : r2.theme, h2 = () => {
          };
          a2 ? h2 = function(e3) {
            e3 && e3.stopPropagation(), a2.call(i2, e3);
          } : s2 && (h2 = function(e3) {
            e3 && e3.stopPropagation(), n2.contextMenu(p2.menuClassName, s2, p2.translateX || 0, p2.translateY || 0, p2.width || 0, p2.height || 0, p2), p2.setState(2);
          }), r2.text && r2.symbol ? c2.paddingLeft = eo(c2.paddingLeft, 30) : r2.text || Z(c2, { width: r2.width, height: r2.height, padding: 0 });
          let p2 = o2.button(r2.text || "", 0, 0, h2, c2, void 0, void 0, void 0, void 0, r2.useHTML).addClass(e2.className || "").attr({ title: eo(i2.options.lang[r2._titleKey || r2.titleKey], "") });
          p2.menuClassName = e2.menuClassName || "highcharts-menu-" + n2.btnCount++, r2.symbol && (t2 = o2.symbol(r2.symbol, Math.round((r2.symbolX || 0) - l2 / 2), Math.round((r2.symbolY || 0) - l2 / 2), l2, l2, { width: l2, height: l2 }).addClass("highcharts-button-symbol").attr({ zIndex: 1 }).add(p2), i2.styledMode || t2.attr({ stroke: r2.symbolStroke, fill: r2.symbolFill, "stroke-width": r2.symbolStrokeWidth || 1 })), p2.add(n2.group).align(Z(r2, { width: p2.width, x: eo(r2.x, n2.buttonOffset) }), true, "spacingBox"), n2.buttonOffset += ((p2.width || 0) + (r2.buttonSpacing || 0)) * ("right" === r2.align ? -1 : 1), n2.svgElements.push(p2, t2);
        }
        afterPrint() {
          let e2 = this.chart;
          if (!this.printReverseInfo) return;
          let { childNodes: t2, origDisplay: n2, resetParams: i2 } = this.printReverseInfo;
          this.moveContainers(e2.renderTo), [].forEach.call(t2, function(e3, t3) {
            1 === e3.nodeType && (e3.style.display = n2[t3] || "");
          }), this.isPrinting = false, i2 && e2.setSize.apply(e2, i2), delete this.printReverseInfo, eh.printingChart = void 0, ee(e2, "afterPrint");
        }
        beforePrint() {
          var _a;
          let e2 = this.chart, t2 = B.body, n2 = this.options.printMaxWidth, i2 = { childNodes: t2.childNodes, origDisplay: [], resetParams: void 0 };
          this.isPrinting = true, (_a = e2.pointer) == null ? void 0 : _a.reset(void 0, 0), ee(e2, "beforePrint"), n2 && e2.chartWidth > n2 && (i2.resetParams = [e2.options.chart.width, void 0, false], e2.setSize(n2, void 0, false)), [].forEach.call(i2.childNodes, function(e3, t3) {
            1 === e3.nodeType && (i2.origDisplay[t3] = e3.style.display, e3.style.display = "none");
          }), this.moveContainers(t2), this.printReverseInfo = i2;
        }
        contextMenu(e2, t2, n2, i2, o2, r2, a2) {
          var _a, _b, _c;
          let s2 = this, l2 = s2.chart, c2 = l2.options.navigation, h2 = l2.chartWidth, p2 = l2.chartHeight, u2 = "cache-" + e2, g2 = Math.max(o2, r2), f2, m2 = l2[u2];
          m2 || (s2.contextMenuEl = l2[u2] = m2 = J("div", { className: e2 }, { position: "absolute", zIndex: 1e3, padding: g2 + "px", pointerEvents: "auto", ...l2.renderer.style }, ((_a = l2.scrollablePlotArea) == null ? void 0 : _a.fixedDiv) || l2.container), f2 = J("ul", { className: "highcharts-menu" }, l2.styledMode ? {} : { listStyle: "none", margin: 0, padding: 0 }, m2), l2.styledMode || _(f2, Z({ MozBoxShadow: "3px 3px 10px #0008", WebkitBoxShadow: "3px 3px 10px #0008", boxShadow: "3px 3px 10px #0008" }, (c2 == null ? void 0 : c2.menuStyle) || {})), m2.hideMenu = function() {
            _(m2, { display: "none" }), a2 && a2.setState(0), l2.exporting && (l2.exporting.openMenu = false), _(l2.renderTo, { overflow: "hidden" }), _(l2.container, { overflow: "hidden" }), K(m2.hideTimer), ee(l2, "exportMenuHidden");
          }, (_b = s2.events) == null ? void 0 : _b.push(z(m2, "mouseleave", function() {
            m2.hideTimer = q.setTimeout(m2.hideMenu, 500);
          }), z(m2, "mouseenter", function() {
            K(m2.hideTimer);
          }), z(B, "mouseup", function(t3) {
            var _a2;
            ((_a2 = l2.pointer) == null ? void 0 : _a2.inClass(t3.target, e2)) || m2.hideMenu();
          }), z(m2, "click", function() {
            var _a2;
            ((_a2 = l2.exporting) == null ? void 0 : _a2.openMenu) && m2.hideMenu();
          })), t2.forEach(function(e3) {
            var _a2;
            if ("string" == typeof e3 && ((_a2 = s2.options.menuItemDefinitions) == null ? void 0 : _a2[e3]) && (e3 = s2.options.menuItemDefinitions[e3]), et(e3, true)) {
              let t3;
              e3.separator ? t3 = J("hr", void 0, void 0, f2) : ("viewData" === e3.textKey && s2.isDataTableVisible && (e3.textKey = "hideData"), t3 = J("li", { className: "highcharts-menu-item", onclick: function(t4) {
                t4 && t4.stopPropagation(), m2.hideMenu(), "string" != typeof e3 && e3.onclick && e3.onclick.apply(l2, arguments);
              } }, void 0, f2), d().setElementHTML(t3, e3.text || l2.options.lang[e3.textKey]), l2.styledMode || (t3.onmouseover = function() {
                _(this, (c2 == null ? void 0 : c2.menuItemHoverStyle) || {});
              }, t3.onmouseout = function() {
                _(this, (c2 == null ? void 0 : c2.menuItemStyle) || {});
              }, _(t3, Z({ cursor: "pointer" }, (c2 == null ? void 0 : c2.menuItemStyle) || {})))), s2.divElements.push(t3);
            }
          }), s2.divElements.push(f2, m2), s2.menuHeight = m2.offsetHeight, s2.menuWidth = m2.offsetWidth);
          let y2 = { display: "block" };
          n2 + (s2.menuWidth || 0) > h2 ? y2.right = h2 - n2 - o2 - g2 + "px" : y2.left = n2 - g2 + "px", i2 + r2 + (s2.menuHeight || 0) > p2 && ((_c = a2.alignOptions) == null ? void 0 : _c.verticalAlign) !== "top" ? y2.bottom = p2 - i2 - g2 + "px" : y2.top = i2 + r2 - g2 + "px", _(m2, y2), _(l2.renderTo, { overflow: "" }), _(l2.container, { overflow: "" }), l2.exporting && (l2.exporting.openMenu = true), ee(l2, "exportMenuShown");
        }
        destroy(e2) {
          let t2, n2 = e2 ? e2.target : this.chart, { divElements: i2, events: o2, svgElements: r2 } = this;
          r2.forEach((e3, i3) => {
            e3 && (e3.onclick = e3.ontouchstart = null, n2[t2 = "cache-" + e3.menuClassName] && delete n2[t2], r2[i3] = e3.destroy());
          }), r2.length = 0, this.group && (this.group.destroy(), delete this.group), i2.forEach(function(e3, t3) {
            e3 && (K(e3.hideTimer), ea(e3, "mouseleave"), i2[t3] = e3.onmouseout = e3.onmouseover = e3.ontouchstart = e3.onclick = null, X(e3));
          }), i2.length = 0, o2 && (o2.forEach(function(e3) {
            e3();
          }), o2.length = 0);
        }
        async downloadSVG(e2, t2) {
          let n2, i2 = { svg: e2, exportingOptions: t2, exporting: this };
          if (ee(eh.prototype, "downloadSVG", i2), i2.defaultPrevented) return;
          let { type: o2, filename: r2, scale: a2, libURL: s2 } = eh.prepareImageOptions(t2);
          if ("application/pdf" === o2) throw Error("Offline exporting logic for PDF type is not found.");
          if ("image/svg+xml" === o2) {
            if (void 0 !== q.MSBlobBuilder) {
              let t3 = new q.MSBlobBuilder();
              t3.append(e2), n2 = t3.getBlob("image/svg+xml");
            } else n2 = eh.svgToDataURL(e2);
            U(n2, r2);
          } else {
            n2 = eh.svgToDataURL(e2);
            try {
              eh.objectURLRevoke = true;
              let e3 = await eh.imageToDataURL(n2, a2, o2);
              U(e3, r2);
            } catch (c2) {
              if ("No canvas found!" === c2.message) throw c2;
              if (e2.length > 1e8) throw Error("Input too long");
              let t3 = B.createElement("canvas"), n3 = t3.getContext("2d"), i3 = e2.match(/^<svg[^>]*\s{,1000}width\s{,1000}=\s{,1000}\"?(\d+)\"?[^>]*>/), l2 = e2.match(/^<svg[^>]*\s{0,1000}height\s{,1000}=\s{,1000}\"?(\d+)\"?[^>]*>/);
              if (n3 && i3 && l2) {
                let c3 = i3[1] * a2, h2 = l2[1] * a2;
                t3.width = c3, t3.height = h2, q.canvg || (eh.objectURLRevoke = true, await I(s2 + "canvg.js")), q.canvg.Canvg.fromString(n3, e2).start(), U(q.navigator.msSaveOrOpenBlob ? t3.msToBlob() : t3.toDataURL(o2), r2);
              }
            } finally {
              if (eh.objectURLRevoke) try {
                ec.revokeObjectURL(n2);
              } catch {
              }
            }
          }
        }
        async exportChart(e2, t2) {
          if ((e2 = en(this.options, e2)).local) await this.localExport(e2, t2 || {});
          else {
            let n2 = this.getSVGForExport(e2, t2);
            e2.url && await M.post(e2.url, { filename: e2.filename ? e2.filename.replace(/\//g, "-") : this.getFilename(), type: e2.type, width: e2.width, scale: e2.scale, svg: n2 }, e2.fetchOptions);
          }
        }
        async fallbackToServer(e2, t2) {
          false === e2.fallbackToExportServer ? e2.error ? e2.error(e2, t2) : Y(28, true) : "application/pdf" === e2.type && (e2.local = false, await this.exportChart(e2));
        }
        getChartHTML(e2) {
          let t2 = this.chart;
          return e2 && this.inlineStyles(), this.resolveCSSVariables(), t2.container.innerHTML;
        }
        getFilename() {
          var _a;
          let e2 = (_a = this.chart.userOptions.title) == null ? void 0 : _a.text, t2 = this.options.filename;
          return t2 ? t2.replace(/\//g, "-") : ("string" == typeof e2 && (t2 = e2.toLowerCase().replace(/<\/?[^>]+(>|$)/g, "").replace(/[\s_]+/g, "-").replace(/[^a-z\d\-]/g, "").replace(/^[\-]+/g, "").replace(/[\-]+/g, "-").substr(0, 24).replace(/[\-]+$/g, "")), (!t2 || t2.length < 5) && (t2 = "chart"), t2);
        }
        getSVG(e2) {
          var _a, _b, _c, _d;
          let t2 = this.chart, n2, i2, o2 = en(t2.options, e2);
          o2.plotOptions = en(t2.userOptions.plotOptions, e2 == null ? void 0 : e2.plotOptions), o2.time = en(t2.userOptions.time, e2 == null ? void 0 : e2.time);
          let r2 = J("div", void 0, { position: "absolute", top: "-9999em", width: t2.chartWidth + "px", height: t2.chartHeight + "px" }, B.body), a2 = t2.renderTo.style.width, s2 = t2.renderTo.style.height, l2 = ((_a = o2.exporting) == null ? void 0 : _a.sourceWidth) || o2.chart.width || /px$/.test(a2) && parseInt(a2, 10) || (o2.isGantt ? 800 : 600), c2 = ((_b = o2.exporting) == null ? void 0 : _b.sourceHeight) || o2.chart.height || /px$/.test(s2) && parseInt(s2, 10) || 400;
          Z(o2.chart, { animation: false, renderTo: r2, forExport: true, renderer: "SVGRenderer", width: l2, height: c2 }), o2.exporting && (o2.exporting.enabled = false), delete o2.data, o2.series = [], t2.series.forEach(function(e3) {
            var _a2;
            (i2 = en(e3.userOptions, { animation: false, enableMouseTracking: false, showCheckbox: false, visible: e3.visible })).isInternal || ((_a2 = o2 == null ? void 0 : o2.series) == null ? void 0 : _a2.push(i2));
          });
          let h2 = {};
          t2.axes.forEach(function(e3) {
            e3.userOptions.internalKey || (e3.userOptions.internalKey = el()), o2 && !e3.options.isInternal && (h2[e3.coll] || (h2[e3.coll] = true, o2[e3.coll] = []), o2[e3.coll].push(en(e3.userOptions, { visible: e3.visible, type: e3.type, uniqueNames: e3.uniqueNames })));
          }), o2.colorAxis = t2.userOptions.colorAxis;
          let p2 = new t2.constructor(o2, t2.callback);
          return e2 && ["xAxis", "yAxis", "series"].forEach(function(t3) {
            e2[t3] && p2.update({ [t3]: e2[t3] });
          }), t2.axes.forEach(function(t3) {
            let n3 = Q(p2.axes, (e3) => e3.options.internalKey === t3.userOptions.internalKey);
            if (n3) {
              let i3 = t3.getExtremes(), o3 = es((e2 == null ? void 0 : e2[t3.coll]) || {})[0], r3 = "min" in o3 ? o3.min : i3.userMin, a3 = "max" in o3 ? o3.max : i3.userMax;
              (void 0 !== r3 && r3 !== n3.min || void 0 !== a3 && a3 !== n3.max) && n3.setExtremes(r3 ?? void 0, a3 ?? void 0, true, false);
            }
          }), n2 = ((_d = p2.exporting) == null ? void 0 : _d.getChartHTML(t2.styledMode || ((_c = o2.exporting) == null ? void 0 : _c.applyStyleSheets))) || "", ee(t2, "getSVG", { chartCopy: p2 }), n2 = eh.sanitizeSVG(n2, o2), o2 = void 0, p2.destroy(), X(r2), n2;
        }
        getSVGForExport(e2, t2) {
          let n2 = this.options;
          return this.getSVG(en({ chart: { borderRadius: 0 } }, n2.chartOptions, t2, { exporting: { sourceWidth: (e2 == null ? void 0 : e2.sourceWidth) || n2.sourceWidth, sourceHeight: (e2 == null ? void 0 : e2.sourceHeight) || n2.sourceHeight } }));
        }
        inlineStyles() {
          var _a;
          let e2, t2 = eh.inlineDenylist, n2 = eh.inlineAllowlist, i2 = {}, o2 = J("iframe", void 0, { width: "1px", height: "1px", visibility: "hidden" }, B.body), r2 = (_a = o2.contentWindow) == null ? void 0 : _a.document;
          r2 && r2.body.appendChild(r2.createElementNS(W, "svg")), !function o3(a2) {
            let s2, l2, c2, h2, p2, d2, u2 = {};
            if (r2 && 1 === a2.nodeType && -1 === eh.unstyledElements.indexOf(a2.nodeName)) {
              if (s2 = q.getComputedStyle(a2, null), l2 = "svg" === a2.nodeName ? {} : q.getComputedStyle(a2.parentNode, null), !i2[a2.nodeName]) {
                e2 = r2.getElementsByTagName("svg")[0], c2 = r2.createElementNS(a2.namespaceURI, a2.nodeName), e2.appendChild(c2);
                let t3 = q.getComputedStyle(c2, null), n3 = {};
                for (let e3 in t3) e3.length < 1e3 && "string" == typeof t3[e3] && !/^\d+$/.test(e3) && (n3[e3] = t3[e3]);
                i2[a2.nodeName] = n3, "text" === a2.nodeName && delete i2.text.fill, e2.removeChild(c2);
              }
              for (let e3 in s2) (G || $ || V || Object.hasOwnProperty.call(s2, e3)) && function(e4, o4) {
                if (h2 = p2 = false, n2.length) {
                  for (d2 = n2.length; d2-- && !p2; ) p2 = n2[d2].test(o4);
                  h2 = !p2;
                }
                for ("transform" === o4 && "none" === e4 && (h2 = true), d2 = t2.length; d2-- && !h2; ) {
                  if (o4.length > 1e3) throw Error("Input too long");
                  h2 = t2[d2].test(o4) || "function" == typeof e4;
                }
                !h2 && (l2[o4] !== e4 || "svg" === a2.nodeName) && i2[a2.nodeName][o4] !== e4 && (eh.inlineToAttributes && -1 === eh.inlineToAttributes.indexOf(o4) ? u2[o4] = e4 : e4 && a2.setAttribute(eh.hyphenate(o4), e4));
              }(s2[e3], e3);
              if (_(a2, u2), "svg" === a2.nodeName && a2.setAttribute("stroke-width", "1px"), "text" === a2.nodeName) return;
              [].forEach.call(a2.children || a2.childNodes, o3);
            }
          }(this.chart.container.querySelector("svg")), e2.parentNode.removeChild(e2), o2.parentNode.removeChild(o2);
        }
        async localExport(e2, t2) {
          var _a, _b, _c;
          let n2 = this.chart, i2, o2, r2 = null, a2;
          if ($ && n2.styledMode && !eh.inlineAllowlist.length && eh.inlineAllowlist.push(/^blockSize/, /^border/, /^caretColor/, /^color/, /^columnRule/, /^columnRuleColor/, /^cssFloat/, /^cursor/, /^fill$/, /^fillOpacity/, /^font/, /^inlineSize/, /^length/, /^lineHeight/, /^opacity/, /^outline/, /^parentRule/, /^rx$/, /^ry$/, /^stroke/, /^textAlign/, /^textAnchor/, /^textDecoration/, /^transform/, /^vectorEffect/, /^visibility/, /^x$/, /^y$/), $ && ("application/pdf" === e2.type || n2.container.getElementsByTagName("image").length && "image/svg+xml" !== e2.type) || "application/pdf" === e2.type && [].some.call(n2.container.getElementsByTagName("image"), function(e3) {
            let t3 = e3.getAttribute("href");
            return "" !== t3 && "string" == typeof t3 && 0 !== t3.indexOf("data:");
          })) return void await this.fallbackToServer(e2, Error("Image type not supported for this chart/browser."));
          let s2 = z(n2, "getSVG", (e3) => {
            o2 = e3.chartCopy.options, a2 = (i2 = e3.chartCopy.container.cloneNode(true)) && i2.getElementsByTagName("image") || [];
          });
          try {
            let n3;
            for (let n4 of (this.getSVGForExport(e2, t2), a2 ? Array.from(a2) : [])) if (r2 = n4.getAttributeNS("http://www.w3.org/1999/xlink", "href")) {
              eh.objectURLRevoke = false;
              let t3 = await eh.imageToDataURL(r2, (e2 == null ? void 0 : e2.scale) || 1, (e2 == null ? void 0 : e2.type) || "image/png");
              n4.setAttributeNS("http://www.w3.org/1999/xlink", "href", t3);
            } else n4.parentNode.removeChild(n4);
            let s3 = i2 == null ? void 0 : i2.querySelector("svg");
            s3 && !((_c = (_b = (_a = e2.chartOptions) == null ? void 0 : _a.chart) == null ? void 0 : _b.style) == null ? void 0 : _c.fontFamily) && await eh.inlineFonts(s3);
            let l2 = (n3 = i2 == null ? void 0 : i2.innerHTML, eh.sanitizeSVG(n3 || "", o2));
            if (l2.indexOf("<foreignObject") > -1 && "image/svg+xml" !== e2.type && ($ || "application/pdf" === e2.type)) throw Error("Image type not supported for charts with embedded HTML");
            return await this.downloadSVG(l2, Z({ filename: this.getFilename() }, e2)), l2;
          } catch (t3) {
            await this.fallbackToServer(e2, t3);
          } finally {
            s2();
          }
        }
        moveContainers(e2) {
          let t2 = this.chart, { scrollablePlotArea: n2 } = t2;
          (n2 ? [n2.fixedDiv, n2.scrollingContainer] : [t2.container]).forEach(function(t3) {
            e2.appendChild(t3);
          });
        }
        print() {
          let e2 = this.chart;
          this.isPrinting || (eh.printingChart = e2, V || this.beforePrint(), setTimeout(() => {
            q.focus(), q.print(), V || setTimeout(() => {
              var _a;
              (_a = e2.exporting) == null ? void 0 : _a.afterPrint();
            }, 1e3);
          }, 1));
        }
        render() {
          let e2 = this, { chart: t2, options: n2 } = e2, i2 = (e2 == null ? void 0 : e2.isDirty) || !(e2 == null ? void 0 : e2.svgElements.length);
          e2.buttonOffset = 0, e2.isDirty && e2.destroy(), i2 && false !== n2.enabled && (e2.events = [], e2.group || (e2.group = t2.renderer.g("exporting-group").attr({ zIndex: 3 }).add()), ei(n2 == null ? void 0 : n2.buttons, function(t3) {
            e2.addButton(t3);
          }), e2.isDirty = false);
        }
        resolveCSSVariables() {
          Array.from(this.chart.container.querySelectorAll("*")).forEach((e2) => {
            ["color", "fill", "stop-color", "stroke"].forEach((t2) => {
              var _a;
              let n2 = e2.getAttribute(t2);
              (n2 == null ? void 0 : n2.includes("var(")) && e2.setAttribute(t2, getComputedStyle(e2).getPropertyValue(t2));
              let i2 = (_a = e2.style) == null ? void 0 : _a[t2];
              (i2 == null ? void 0 : i2.includes("var(")) && (e2.style[t2] = getComputedStyle(e2).getPropertyValue(t2));
            });
          });
        }
        update(e2, t2) {
          this.isDirty = true, en(true, this.options, e2), eo(t2, true) && this.chart.redraw();
        }
      }
      eh.inlineAllowlist = [], eh.inlineDenylist = [/-/, /^(clipPath|cssText|d|height|width)$/, /^font$/, /[lL]ogical(Width|Height)$/, /^parentRule$/, /^(cssRules|ownerRules)$/, /perspective/, /TapHighlightColor/, /^transition/, /^length$/, /^\d+$/], eh.inlineToAttributes = ["fill", "stroke", "strokeLinecap", "strokeLinejoin", "strokeWidth", "textAnchor", "x", "y"], eh.loadEventDeferDelay = 150 * !!$, eh.unstyledElements = ["clipPath", "defs", "desc"], function(e2) {
        function t2(e3) {
          let t3 = e3.exporting;
          t3 && (t3.render(), z(e3, "redraw", function() {
            var _a;
            (_a = this.exporting) == null ? void 0 : _a.render();
          }), z(e3, "destroy", function() {
            var _a;
            (_a = this.exporting) == null ? void 0 : _a.destroy();
          }));
        }
        function n2() {
          let t3 = this;
          t3.options.exporting && (t3.exporting = new e2(t3, t3.options.exporting), f.compose(t3).navigation.addUpdate((e3, n3) => {
            t3.exporting && (t3.exporting.isDirty = true, en(true, t3.options.navigation, e3), eo(n3, true) && t3.redraw());
          }));
        }
        function i2({ alignTo: e3, key: t3, textPxLength: n3 }) {
          var _a, _b, _c;
          let i3 = this.options.exporting, { align: o2, buttonSpacing: r2 = 0, verticalAlign: a2, width: s2 = 0 } = en((_a = this.options.navigation) == null ? void 0 : _a.buttonOptions, (_b = i3 == null ? void 0 : i3.buttons) == null ? void 0 : _b.contextButton), l2 = e3.width - n3, c2 = s2 + r2;
          ((i3 == null ? void 0 : i3.enabled) ?? true) && "title" === t3 && "right" === o2 && "top" === a2 && l2 < 2 * c2 && (l2 < c2 ? e3.width -= c2 : ((_c = this.title) == null ? void 0 : _c.alignValue) !== "left" && (e3.x -= c2 - l2 / 2));
        }
        e2.compose = function(o2, r2) {
          E.compose(r2), N.compose(o2), er(j, "Exporting") && (Z(g().prototype, { exportChart: async function(e3, t3) {
            var _a;
            await ((_a = this.exporting) == null ? void 0 : _a.exportChart(e3, t3));
          }, getChartHTML: function(e3) {
            var _a;
            return (_a = this.exporting) == null ? void 0 : _a.getChartHTML(e3);
          }, getFilename: function() {
            var _a;
            return (_a = this.exporting) == null ? void 0 : _a.getFilename();
          }, getSVG: function(e3) {
            var _a;
            return (_a = this.exporting) == null ? void 0 : _a.getSVG(e3);
          }, print: function() {
            var _a;
            return (_a = this.exporting) == null ? void 0 : _a.print();
          } }), o2.prototype.callbacks.push(t2), z(o2, "afterInit", n2), z(o2, "layOutTitle", i2), V && q.matchMedia("print").addListener(function(t3) {
            var _a, _b;
            e2.printingChart && (t3.matches ? (_a = e2.printingChart.exporting) == null ? void 0 : _a.beforePrint() : (_b = e2.printingChart.exporting) == null ? void 0 : _b.afterPrint());
          }), D(C));
        };
      }(eh || (eh = {}));
      let ep = eh, ed = h();
      ed.Exporting = ep, ed.HttpUtilities = ed.HttpUtilities || M, ed.ajax = ed.HttpUtilities.ajax, ed.getJSON = ed.HttpUtilities.getJSON, ed.post = ed.HttpUtilities.post, ep.compose(ed.Chart, ed.Renderer);
      let eu = h();
      return l.default;
    })());
  }
});
export default require_exporting();
//# sourceMappingURL=highcharts_modules_exporting.js.map
